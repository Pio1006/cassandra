--- a/src/java/org/apache/cassandra/io/sstable/format/big/BigFormat.java
+++ b/src/java/org/apache/cassandra/io/sstable/format/big/BigFormat.java
@@ -141,13 +141,8 @@
         // md (3.0.18, 3.11.4): corrected sstable min/max clustering
         // me (3.0.25, 3.11.11): added hostId of the node from which the sstable originated
 
-<<<<<<<
         // na (4.0-rc1): uncompressed chunks, pending repair session, isTransient, checksummed sstable metadata file, new Bloomfilter format
         // nb (4.0.0): originating host id
-=======
-        // na (4.0.0): uncompressed chunks, pending repair session, isTransient, checksummed sstable metadata file, new Bloomfilter format
-        // nb (4.1.0): improved min/max
->>>>>>>
         //
         // NOTE: when adding a new version, please add that to LegacySSTableTest, too.
 
@@ -156,12 +151,9 @@
         private final boolean hasCommitLogLowerBound;
         private final boolean hasCommitLogIntervals;
         private final boolean hasAccurateMinMax;
-<<<<<<<
+        private final boolean hasOriginatingHostId;
         private final boolean hasImprovedMinMax;
         private final boolean hasPartitionLevelDeletionPresenceMarker;
-=======
-        private final boolean hasOriginatingHostId;
->>>>>>>
         public final boolean hasMaxCompressedLength;
         private final boolean hasPendingRepair;
         private final boolean hasMetadataChecksum;
@@ -183,12 +175,9 @@
             hasCommitLogLowerBound = version.compareTo("mb") >= 0;
             hasCommitLogIntervals = version.compareTo("mc") >= 0;
             hasAccurateMinMax = version.compareTo("md") >= 0;
-<<<<<<<
+            hasOriginatingHostId = version.matches("(m[e-z])|(n[b-z])");
             hasImprovedMinMax = version.compareTo("nb") >= 0;
             hasPartitionLevelDeletionPresenceMarker = version.compareTo("nb") >= 0;
-=======
-            hasOriginatingHostId = version.matches("(m[e-z])|(n[b-z])");
->>>>>>>
             hasMaxCompressedLength = version.compareTo("na") >= 0;
             hasPendingRepair = version.compareTo("na") >= 0;
             hasIsTransient = version.compareTo("na") >= 0;
--- a/src/java/org/apache/cassandra/io/sstable/metadata/MetadataCollector.java
+++ b/src/java/org/apache/cassandra/io/sstable/metadata/MetadataCollector.java
@@ -18,20 +18,14 @@
 package org.apache.cassandra.io.sstable.metadata;
 
 import java.nio.ByteBuffer;
-<<<<<<<
-=======
 import java.util.ArrayList;
->>>>>>>
 import java.util.Collections;
 import java.util.EnumMap;
 import java.util.Map;
 import java.util.UUID;
 
-<<<<<<<
-=======
 import com.google.common.base.Preconditions;
 
->>>>>>>
 import com.clearspring.analytics.stream.cardinality.HyperLogLogPlus;
 import com.clearspring.analytics.stream.cardinality.ICardinality;
 import org.apache.cassandra.db.*;
@@ -43,10 +37,7 @@
 import org.apache.cassandra.io.sstable.SSTable;
 import org.apache.cassandra.io.sstable.format.SSTableReader;
 import org.apache.cassandra.service.ActiveRepairService;
-<<<<<<<
-=======
 import org.apache.cassandra.service.StorageService;
->>>>>>>
 import org.apache.cassandra.utils.EstimatedHistogram;
 import org.apache.cassandra.utils.MurmurHash;
 import org.apache.cassandra.utils.streamhist.StreamingTombstoneHistogramBuilder;
@@ -148,17 +139,15 @@
         this(comparator, StorageService.instance.getLocalHostUUID());
     }
 
-<<<<<<<
+    public MetadataCollector(ClusteringComparator comparator, UUID originatingHostId)
+    {
+        this.comparator = comparator;
+
         int clusteringTypesNum = comparator.size();
         this.comparators = new AbstractType[clusteringTypesNum];
         for (int i = 0; i < clusteringTypesNum; i++)
             comparators[i] = comparator.subtype(i);
-=======
-    public MetadataCollector(ClusteringComparator comparator, UUID originatingHostId)
-    {
-        this.comparator = comparator;
         this.originatingHostId = originatingHostId;
->>>>>>>
     }
 
     public MetadataCollector(Iterable<SSTableReader> sstables, ClusteringComparator comparator, int level)
--- a/src/java/org/apache/cassandra/io/sstable/metadata/StatsMetadata.java
+++ b/src/java/org/apache/cassandra/io/sstable/metadata/StatsMetadata.java
@@ -40,19 +40,12 @@
 import org.apache.cassandra.io.sstable.format.Version;
 import org.apache.cassandra.io.util.DataInputPlus;
 import org.apache.cassandra.io.util.DataOutputPlus;
-<<<<<<<
 import org.apache.cassandra.net.MessagingService;
-=======
 import org.apache.cassandra.serializers.AbstractTypeSerializer;
->>>>>>>
 import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.EstimatedHistogram;
 import org.apache.cassandra.utils.UUIDSerializer;
-<<<<<<<
-import org.apache.cassandra.utils.UUIDSerializer;
-=======
 import org.apache.cassandra.utils.streamhist.TombstoneHistogram;
->>>>>>>
 
 /**
  * SSTable metadata that always stay on heap.
@@ -340,17 +333,15 @@
                 size += TypeSizes.sizeof(component.isTransient);
             }
 
-<<<<<<<
+            if (version.hasPartitionLevelDeletionsPresenceMarker())
+                size += TypeSizes.sizeof(component.hasPartitionLevelDeletions);
+
             if (version.hasOriginatingHostId())
             {
                 size += 1; // boolean: is originatingHostId present
                 if (component.originatingHostId != null)
                     size += UUIDSerializer.serializer.serializedSize(component.originatingHostId, version.correspondingMessagingVersion());
             }
-=======
-            if (version.hasPartitionLevelDeletionsPresenceMarker())
-                size += TypeSizes.sizeof(component.hasPartitionLevelDeletions);
->>>>>>>
 
             return size;
         }
@@ -420,7 +411,9 @@
                 out.writeBoolean(component.isTransient);
             }
 
-<<<<<<<
+            if (version.hasPartitionLevelDeletionsPresenceMarker())
+                out.writeBoolean(component.hasPartitionLevelDeletions);
+
             if (version.hasOriginatingHostId())
             {
                 if (component.originatingHostId != null)
@@ -433,10 +426,6 @@
                     out.writeByte(0);
                 }
             }
-=======
-            if (version.hasPartitionLevelDeletionsPresenceMarker())
-                out.writeBoolean(component.hasPartitionLevelDeletions);
->>>>>>>
         }
 
         public StatsMetadata deserialize(Version version, DataInputPlus in) throws IOException
@@ -524,17 +513,15 @@
 
             boolean isTransient = version.hasIsTransient() && in.readBoolean();
 
-<<<<<<<
             // If not recorded, the only time we can guarantee there is no partition level deletion is if there is no
             // deletion at all. Otherwise, we have to assume there may be some.
             boolean hasPartitionLevelDeletions = version.hasPartitionLevelDeletionsPresenceMarker()
                                                  ? in.readBoolean()
                                                  : minLocalDeletionTime != Cell.NO_DELETION_TIME;
-=======
+
             UUID originatingHostId = null;
             if (version.hasOriginatingHostId() && in.readByte() != 0)
                 originatingHostId = UUIDSerializer.serializer.deserialize(in, 0);
->>>>>>>
 
             return new StatsMetadata(partitionSizes,
                                      columnCounts,
